package chapter09;

public class Main {

	public static void main(String[] args) {
		A1 a = new A1();//일반적인 인스턴스 생성
		a.a1();
		
		A a1 = new A1();//참조타입을 인터페이스로 선언 가능 (인스턴스는 인터페이스를 구현 한 클래스)
		a1.a1();//A인터페이스는 a1메소드의 존재를 알고 있다.
		
		C1 c1 = new C1(); // 다중 구현 클래스
		c1.a1(); // 다중 구현 클래스이므로 구현된 모든 메소드의 존재를 알고 있다. - 실행 가능
		c1.b1();
		
		A ca = new C1(); // 다중 구현 클래스로 만든 인스턴스 - 참조 타입은 하나의 인터페이스 
		ca.a1();//참조타입이 알고 있는 메소드 실행 가능
		//ca.b1();//참조타입이 모르고 있는 메소드 실행 불가능 - 인스턴스에는 존재
		
		A da = new D1();// 상속한 부모 인터 페이스를 참조타입으로 상속받은 자식 인터페이스로 구현한 인스턴스
		da.a1();//부모 인터페이스 타입이 알고 있는 메소드 실행 가능
		//da.b1();//부모 인터페이스 타입이 모르고 있는 메소드 실행 불가능 - 인스턴스에는 존재
		//da.d1();//부모 인터페이스 타입이 모르고 있는 메소드 실행 불가능 - 인스턴스에는 존재
		
		B db = new D1();// 상속한 부모 인터 페이스를 참조타입으로 상속받은 자식 인터페이스로 구현한 인스턴스
		//db.a1();//부모 인터페이스 타입이 모르고 있는 메소드 실행 불가능 - 인스턴스에는 존재
		db.b1();//부모 인터페이스 타입이 알고 있는 메소드 실행 가능
		//db.d1();//부모 인터페이스 타입이 모르고 있는 메소드 실행 불가능 - 인스턴스에는 존재

		D dd = new D1();// 상속한 부모 인터 페이스를 참조타입으로 상속받은 자식 인터페이스로 구현한 인스턴스
		dd.a1();//부모 인터페이스 타입이 알고 있는 메소드 실행 가능
		dd.b1();//부모 인터페이스 타입이 알고 있는 메소드 실행 가능
		dd.d1();//부모 인터페이스 타입이 알고 있는 메소드 실행 가능
		
		methodA(new D1());
		methodB(new D1());
		methodD(new D1());
		
		D d1 = new D1();
		d1.a1(); d1.b1(); d1.d1();//자식 인터페이스는 모든 메소드를 안다.
		
		A a2 = d1;//자식 인터페이스로 구현한 인스턴스는 부모 참조타입 변수에 할당 가능
		a2.a1(); //그러나 현재타입이 모르는 메소드는 실행 안됨. 현재 참조타입이 중요함.
		
		B b2 = (B) a2; //A와 B는 상관 없지만 강제 형변환 가능.
		b2.b1(); //그러나 현재타입이 모르는 메소드는 실행 안됨. 현재 참조타입이 중요함.
		
		B b3 = null;
		if (a2 instanceof B){//a2 내부 객체(인스턴스)는 타입 B로 사용이 가능한가?
			b3 = (B)a2; //a2 내부의 인스턴스는 타입B로 선언된 변수에 할당 가능
		}				// 다만 메소드는 B가 알고있는 메소드로 한정
		
		if(b3 == null) {
			System.out.println("형변환 실패");
		}else {//형변환 성공
			b3.b1();
		}

	}

	private static void methodA(A a) {
			a.a1();//나머지 안됨. - 부모 인터페이스만 알고있는 메소드만 실행 가능
		
	}

	private static void methodB(B b) {
			b.b1();//나머지 안됨. - 부모 인터페이스만 알고있는 메소드만 실행 가능
		
	}

	private static void methodD(D d) {
		d.a1(); d.b1(); d.d1();//자식 인터페이스는 모든 메소드를 안다.
		
	}

}
